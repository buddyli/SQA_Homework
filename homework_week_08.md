## The Final Homework -- Design how to ensure software quality 

####About SQA
　Software Quality Assurance has its roots in assuring the quality of a manufactured physical product; this is achieved by inspecting the product and evaluating its quality near its completion or at various stages of production. Software however is not as tangible as products that are more physical. Typically, a software product is its functionality and not its use. There is no physical software product to evaluate; there is code and not always accompanying documentation. This “invisible” nature of software adds to the complications of assessing its quality. Industrial products are visible, software products are invisible. Most of the defects in an industrial product can be detected during the manufacturing process, however defects in software products are invisible, as in the fact that parts of a software package may be absent from the beginning.    
　　
  There are further complications with assessing software quality; this is attributed to its inherent complexity. Software systems have grown from standalone systems on a single server to globally networked servers spanning multiple countries, and multiple servers. There are now multiple layers to software, where each layer must interface with the software layer above and that below before interfacing with other external systems.    

  Software may be developed by a team of people who carry out specific roles; the roles are played out during different stages of development. The teamwork driven development life-cycle is open to a multitude of problems, particularly because of the inter-dependence of people in the life-cycle. These problems come in many forms, such as how well the team get together. Poor relationships between individual team members affect the productivity and creativity of the team. The experience of the team can also have implications where experienced members are supporting inexperienced members. If a project team member departs during the middle of the life-cycle, the consequences of this departure can impact on the success of the project. These complications are present in other team orientated projects, but the invisible and intangible nature of the software product compounds this further.    

  The software development team is also affected by external factors such as the customer’s documented requirements and how detailed and accurate they represent the actual requirements. The schedule and budget allocated to the project will also have an effect on the quality of the software. After a project has been completed and installed in its target environment, the system must then be maintained for the duration of its lifespan, the ease with which these changes are conducted successfully can affect the quality of the system.    

  The Software Quality Assurance (SQA) domain lies in the quality management of software during the software engineering development process, SQA defines and measures the inputs and outputs of the development processes and quantifies the quality of the software in terms of defects. 

#### Testing in SQA
  The most intuition way of SQA is software testing. The purpose of software testing is to detect errors in the software. The tester should ideally detect all errors before the software is released to the customer. Full test coverage of a program is impossible. Proving that a program is fault free is equivalent to the famous halting problem of computer science, which is known to be impossible.    

  The main principle of software testing is the process of executing a program with the intent of finding errors. To test the program more thoroughly a tester would need to evaluate the program to detect both types of errors. This principle is thus more detailed to test the program to see if it does what it is supposed to and to see if it does what it is not supposed to do.    

  In order for the tester to find these errors, we have to devise a number of tests to execute on the software itself. Theses tests must be based on prior knowledge of the software. The two main thrusts of testing are firstly based on the composition of the software, i.e. its internal structure. Secondly based on the business or intended purpose of the software, i.e. the functional aspect of the software.    

  Based on one of these box test paradigms the tester will write a series of tests (test cases) to detect any errors and to evaluate if the outcome of the test meets with the software design. Invalid and unexpected input data are more effective at detecting errors than valid and expected data. The problem here is determining whether or not the results of the tests are errors or actual expected results. Where errors are detected, it is prudent to test this area of the program in more detail as statistically more errors will be present in this area. The probability of the existence of more errors in a section of a program is proportional to the number of errors already found in that section.
